---
phase: 01-infrastructure
plan: 08
type: execute
wave: 4
depends_on: ["01-06", "01-07"]
files_modified:
  - apps/shell/src/routes/_auth.dashboard.tsx
  - apps/shell/src/routes/_auth.rent.tsx
  - apps/shell/src/routes/_auth.return.tsx
  - apps/shell/src/routes/_auth.vehicle_exchange.tsx
  - apps/shell/src/routes/_auth.reservation_lookup.tsx
  - apps/shell/src/routes/_auth.carcontrol.tsx
  - apps/shell/src/routes/_auth.aao.tsx
  - apps/shell/src/routes/_auth.reports.tsx
  - apps/shell/src/routes/_auth.settings.tsx
autonomous: false

must_haves:
  truths:
    - "All 9 placeholder routes lazy-load correctly"
    - "Routes are wrapped with MfeErrorBoundary"
    - "User can navigate to all routes and see placeholder content"
    - "User can log in and access protected routes after workspace migration"
  artifacts:
    - path: "apps/shell/src/routes/_auth.dashboard.tsx"
      provides: "Dashboard route with lazy loading"
      contains: "createFileRoute"
    - path: "apps/shell/src/routes/_auth.rent.tsx"
      provides: "Rent route with lazy loading"
      contains: "createFileRoute"
  key_links:
    - from: "apps/shell/src/routes/_auth.*.tsx"
      to: "MfeErrorBoundary"
      via: "wraps route component"
      pattern: "MfeErrorBoundary"
---

<objective>
Configure TanStack Router with placeholder routes for all 9 MFEs

Purpose: Set up the routing infrastructure that MFEs will plug into. Placeholder routes ensure the shell can navigate to all intended destinations before actual MFE code is migrated.
Output: All 9 MFE routes configured with lazy loading, error boundaries, and placeholder content
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-CONTEXT.md
@.planning/phases/01-infrastructure/01-06-SUMMARY.md
@.planning/phases/01-infrastructure/01-07-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update existing routes with MfeErrorBoundary wrapper</name>
  <files>
    - apps/shell/src/routes/_auth.dashboard.tsx
    - apps/shell/src/routes/_auth.rent.tsx
    - apps/shell/src/routes/_auth.return.tsx
    - apps/shell/src/routes/_auth.vehicle_exchange.tsx
    - apps/shell/src/routes/_auth.reservation_lookup.tsx
  </files>
  <action>
1. Update each existing route file to wrap content with MfeErrorBoundary.
   Example for `apps/shell/src/routes/_auth.dashboard.tsx`:
```typescript
import { createFileRoute } from '@tanstack/react-router';
import { MfeErrorBoundary } from '../components/MfeErrorBoundary';
import DashboardPage from '../pages/DashboardPage';

export const Route = createFileRoute('/_auth/dashboard')({
  component: DashboardRoute,
});

function DashboardRoute() {
  return (
    <MfeErrorBoundary mfeName="Dashboard">
      <DashboardPage />
    </MfeErrorBoundary>
  );
}
```

2. Apply same pattern to all routes:
   - _auth.rent.tsx -> wraps RentPage with MfeErrorBoundary mfeName="Rent"
   - _auth.return.tsx -> wraps ReturnPage with MfeErrorBoundary mfeName="Return"
   - _auth.vehicle_exchange.tsx -> wraps VehicleExchangePage with MfeErrorBoundary mfeName="Vehicle Exchange"
   - _auth.reservation_lookup.tsx -> wraps ReservationLookupPage with MfeErrorBoundary mfeName="Reservation Lookup"

3. Keep the existing page components as-is (they will be migrated to MFE packages in Phase 2)
  </action>
  <verify>
- Each route file imports MfeErrorBoundary
- Each route wraps its page component with MfeErrorBoundary
- Routes still navigate correctly
  </verify>
  <done>First 5 routes updated with MfeErrorBoundary wrapper</done>
</task>

<task type="auto">
  <name>Task 2: Update remaining routes with MfeErrorBoundary wrapper</name>
  <files>
    - apps/shell/src/routes/_auth.carcontrol.tsx
    - apps/shell/src/routes/_auth.aao.tsx
    - apps/shell/src/routes/_auth.reports.tsx
    - apps/shell/src/routes/_auth.settings.tsx
  </files>
  <action>
1. Apply same MfeErrorBoundary pattern to remaining routes:
   - _auth.carcontrol.tsx -> wraps CarControl with MfeErrorBoundary mfeName="Car Control"
   - _auth.aao.tsx -> wraps AaoPage with MfeErrorBoundary mfeName="AAO"
   - _auth.reports.tsx -> wraps ReportsPage with MfeErrorBoundary mfeName="Reports"
   - _auth.settings.tsx -> wraps SettingPage with MfeErrorBoundary mfeName="Settings"

2. Example for `apps/shell/src/routes/_auth.carcontrol.tsx`:
```typescript
import { createFileRoute } from '@tanstack/react-router';
import { MfeErrorBoundary } from '../components/MfeErrorBoundary';
import CarControl from '../pages/CarControl';

export const Route = createFileRoute('/_auth/carcontrol')({
  component: CarControlRoute,
});

function CarControlRoute() {
  return (
    <MfeErrorBoundary mfeName="Car Control">
      <CarControl />
    </MfeErrorBoundary>
  );
}
```
  </action>
  <verify>
- All remaining routes wrap page components with MfeErrorBoundary
- All routes render correctly
  </verify>
  <done>All 9 routes updated with MfeErrorBoundary wrapper</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Full shell infrastructure with:
- pnpm workspace monorepo with packages/* and apps/*
- Four shared packages: @packages/ui, @packages/api-client, @packages/event-bus, @packages/mfe-types
- Shell app with layout components (collapsible sidebar, header with breadcrumbs, footer)
- Auth service with role-based access control
- MFE registry with metadata for all 9 MFEs
- Error boundaries wrapping all MFE routes
- Loading progress bar for lazy route transitions
  </what-built>
  <how-to-verify>
1. Start the shell:
   ```bash
   pnpm --filter @apps/shell dev
   ```

2. Test login flow (CRITICAL - verifies auth works after workspace migration):
   - Visit http://localhost:5173
   - Should see login page (not authenticated)
   - Login with admin/admin
   - Should redirect to /dashboard
   - Verify user info displays in header or sidebar

3. Test navigation:
   - Click through all sidebar items
   - Each route should load (may show placeholder content)
   - Loading bar should appear during transitions

4. Test sidebar collapse:
   - On desktop, click collapse button
   - Sidebar should shrink to icon-only rail
   - Refresh page - collapsed state should persist

5. Test error boundary (optional):
   - Temporarily add `throw new Error('test')` in a page component
   - Should see error boundary UI, not white screen
   - Other routes should still work

6. Verify breadcrumbs:
   - Navigate to nested routes
   - Header should show breadcrumb trail

7. Test role-based nav:
   - Logout and login as viewer/viewer
   - Sidebar should show fewer items

8. Test logout:
   - Click logout button
   - Should redirect to login page
   - Navigating to /dashboard should redirect back to login
  </how-to-verify>
  <resume-signal>Type "approved" if all checks pass, or describe issues found</resume-signal>
</task>

</tasks>

<verification>
- All 9 routes wrapped with MfeErrorBoundary
- Navigation between all routes works
- Error in one route doesn't crash others
- Loading bar shows during transitions
- User can log in and access protected routes
</verification>

<success_criteria>
- User can log in and navigate to all 9 routes
- Layout renders consistently (sidebar, header, footer)
- Error boundaries isolate failures
- Loading bar provides visual feedback
- Role-based navigation hiding works
- Login/logout flow works correctly after workspace migration
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-08-SUMMARY.md`
</output>
