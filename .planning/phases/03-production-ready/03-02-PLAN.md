---
phase: 03-production-ready
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - apps/shell/Dockerfile
  - docker/nginx.conf
  - docker-compose.yml
autonomous: false

must_haves:
  truths:
    - "User can run docker-compose up and access the application at localhost:8080"
    - "Refreshing a client-side route (e.g., /dashboard) serves index.html correctly"
    - "Static assets with content hashes have long cache headers"
    - "index.html has no-cache headers to ensure updates are picked up"
  artifacts:
    - path: "apps/shell/Dockerfile"
      provides: "Multi-stage Docker build"
      contains: "FROM node"
    - path: "docker/nginx.conf"
      provides: "SPA routing and caching config"
      contains: "try_files"
    - path: "docker-compose.yml"
      provides: "Local production orchestration"
      contains: "services:"
  key_links:
    - from: "Dockerfile"
      to: "nginx.conf"
      via: "COPY docker/nginx.conf"
      pattern: "COPY.*nginx.conf"
    - from: "docker-compose.yml"
      to: "Dockerfile"
      via: "build context"
      pattern: "build:.*dockerfile"
---

<objective>
Create Docker production setup with multi-stage build and nginx serving

Purpose: Enable local production testing and provide deployment artifacts. Multi-stage build compiles assets in Node container, then serves via lightweight nginx Alpine for ~50MB final image.

Output: Dockerfile, nginx.conf with SPA routing, and docker-compose.yml for local demo
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-production-ready/03-RESEARCH.md

Build context:
- pnpm workspace at root
- Build output in apps/shell/dist/
- PWA assets (sw.js, workbox-*.js, manifest.webmanifest)
- Route-based code splitting (assets/*.js chunks)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create multi-stage Dockerfile</name>
  <files>apps/shell/Dockerfile</files>
  <action>
Create apps/shell/Dockerfile with two stages:

Stage 1 (builder):
- FROM node:23-alpine AS builder
- WORKDIR /app
- Enable corepack for pnpm
- Copy package.json, pnpm-lock.yaml, and pnpm-workspace.yaml from root
- Copy all package.json files from packages/ and apps/ (for workspace resolution)
- Run pnpm install --frozen-lockfile
- Copy entire source tree
- Run pnpm build

Stage 2 (production):
- FROM nginx:alpine
- Copy dist/ from builder stage to /usr/share/nginx/html
- Copy docker/nginx.conf to /etc/nginx/conf.d/default.conf
- Expose port 80
- Default CMD nginx -g "daemon off;"

Key considerations:
- Copy lockfile and workspace config BEFORE source for better layer caching
- Build all packages (pnpm build runs across workspace)
- Use nginx:alpine for minimal image size (~50MB total)
  </action>
  <verify>
File exists at apps/shell/Dockerfile with:
- Two FROM statements (node:23-alpine, nginx:alpine)
- COPY --from=builder pattern
- pnpm install and pnpm build commands
  </verify>
  <done>Multi-stage Dockerfile created with build and production stages</done>
</task>

<task type="auto">
  <name>Task 2: Create nginx configuration for SPA</name>
  <files>docker/nginx.conf</files>
  <action>
Create docker/nginx.conf directory and file:

1. Create docker/ directory at project root (mkdir -p docker)

2. Create nginx.conf with:
```nginx
server {
    listen 80;
    server_name _;
    root /usr/share/nginx/html;
    index index.html;

    # Security headers
    add_header X-Frame-Options "SAMEORIGIN" always;
    add_header X-Content-Type-Options "nosniff" always;
    add_header X-XSS-Protection "1; mode=block" always;

    # Code-split assets with content hash - long cache (1 year)
    location ~* ^/assets/.+\.(js|css|png|jpg|jpeg|gif|ico|svg|woff|woff2|ttf|eot)$ {
        add_header Cache-Control "public, max-age=31536000, immutable";
        try_files $uri =404;
    }

    # Service worker and manifest - short cache
    location ~* \.(webmanifest|sw\.js)$ {
        add_header Cache-Control "public, max-age=0, must-revalidate";
        try_files $uri =404;
    }

    # Workbox runtime - can be cached longer
    location ~* workbox.*\.js$ {
        add_header Cache-Control "public, max-age=31536000, immutable";
        try_files $uri =404;
    }

    # index.html - no cache (always check for updates)
    location = /index.html {
        add_header Cache-Control "public, max-age=0, must-revalidate" always;
        try_files $uri =404;
    }

    # SPA fallback - all other routes serve index.html
    location / {
        try_files $uri $uri/ /index.html;
    }
}
```

Key points:
- /assets/* has immutable cache (hashed filenames)
- index.html has no-cache (must revalidate)
- SPA fallback for client-side routes
- Security headers included
- PWA files handled (manifest, service worker)
  </action>
  <verify>
- File exists at docker/nginx.conf
- Contains try_files $uri $uri/ /index.html for SPA routing
- Contains Cache-Control headers for assets and index.html
  </verify>
  <done>nginx configuration with SPA routing and proper caching created</done>
</task>

<task type="auto">
  <name>Task 3: Create docker-compose.yml</name>
  <files>docker-compose.yml</files>
  <action>
Create docker-compose.yml at project root:

```yaml
version: '3.8'

services:
  web:
    build:
      context: .
      dockerfile: apps/shell/Dockerfile
    ports:
      - "8080:80"
    restart: unless-stopped
    healthcheck:
      test: ["CMD", "wget", "-q", "--spider", "http://localhost:80"]
      interval: 30s
      timeout: 10s
      retries: 3
```

Notes:
- Port 8080 on host maps to 80 in container (avoid conflict with dev server)
- Context is project root (needs workspace files)
- Dockerfile path relative to context
- Use wget for healthcheck (available in nginx:alpine)
  </action>
  <verify>
- File exists at docker-compose.yml
- build.context is "."
- build.dockerfile points to apps/shell/Dockerfile
- Port mapping is 8080:80
  </verify>
  <done>docker-compose.yml created for local production demo</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>Docker production setup with multi-stage build and nginx</what-built>
  <how-to-verify>
1. Build and run the container:
   ```bash
   docker-compose up --build
   ```

2. Wait for build to complete (may take 2-3 minutes first time)

3. Open http://localhost:8080 in browser

4. Verify:
   - Login page loads
   - After login, navigate to /dashboard
   - Refresh the page on /dashboard - should NOT get 404
   - Open DevTools Network tab, check response headers:
     - index.html should have Cache-Control: max-age=0
     - JS files in /assets/ should have Cache-Control with max-age=31536000

5. Stop with Ctrl+C or `docker-compose down`
  </how-to-verify>
  <resume-signal>Type "approved" if everything works, or describe issues</resume-signal>
</task>

</tasks>

<verification>
After completing all tasks:

1. Files exist:
   - apps/shell/Dockerfile
   - docker/nginx.conf
   - docker-compose.yml

2. Docker build succeeds:
   - `docker-compose build` exits 0

3. Container runs:
   - `docker-compose up` starts nginx on port 8080

4. SPA routing works:
   - Direct navigation to /dashboard returns 200 (not 404)
   - Refresh on any route works

5. Caching headers correct:
   - index.html: no-cache
   - assets/*.js: immutable, 1 year
</verification>

<success_criteria>
- docker-compose up --build succeeds
- Application accessible at localhost:8080
- SPA routing works (refresh on /dashboard doesn't 404)
- Code splitting visible in Network tab (multiple JS chunks loaded)
- Cache headers appropriate for each file type
</success_criteria>

<output>
After completion, create `.planning/phases/03-production-ready/03-02-SUMMARY.md`
</output>
