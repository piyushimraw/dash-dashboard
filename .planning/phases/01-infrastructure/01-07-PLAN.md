---
phase: 01-infrastructure
plan: 07
type: execute
wave: 3
depends_on: ["01-03", "01-04"]
files_modified:
  - apps/shell/src/services/mfe-registry.ts
  - apps/shell/src/components/MfeErrorBoundary.tsx
  - apps/shell/src/components/MfeLoadingBar.tsx
autonomous: true

must_haves:
  truths:
    - "MFE registry tracks metadata for each MFE"
    - "Error boundary catches MFE failures without crashing shell"
    - "Loading bar shows during lazy route loading"
  artifacts:
    - path: "apps/shell/src/services/mfe-registry.ts"
      provides: "MFE metadata registry"
      contains: "mfeRegistry"
    - path: "apps/shell/src/components/MfeErrorBoundary.tsx"
      provides: "Error boundary for MFE isolation"
      contains: "getDerivedStateFromError"
    - path: "apps/shell/src/components/MfeLoadingBar.tsx"
      provides: "Top progress bar for route loading"
      min_lines: 20
  key_links:
    - from: "apps/shell/src/services/mfe-registry.ts"
      to: "@packages/mfe-types"
      via: "imports MfeRegistry type"
      pattern: "import.*MfeRegistry.*@packages/mfe-types"
---

<objective>
Create MFE registry and error boundary infrastructure for MFE isolation

Purpose: Enable tracking of MFE metadata and isolate MFE failures so one crash doesn't bring down the shell. The loading bar provides visual feedback during lazy loading.
Output: MFE registry service, error boundary component, and loading progress bar
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-CONTEXT.md
@.planning/phases/01-infrastructure/01-03-SUMMARY.md
@.planning/phases/01-infrastructure/01-04-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create MFE registry service with metadata for all 9 MFEs</name>
  <files>
    - apps/shell/src/services/mfe-registry.ts
  </files>
  <action>
1. Create `apps/shell/src/services/mfe-registry.ts`:
```typescript
import type { MfeRegistry, MfeMetadata, MfeLoadingState } from '@packages/mfe-types';
import { create } from 'zustand';

/**
 * Static MFE registry - metadata for all known MFEs
 */
export const mfeRegistry: MfeRegistry = {
  'dashboard': {
    id: 'dashboard',
    name: 'Dashboard',
    routes: ['/dashboard'],
    version: '1.0.0',
    enabled: true,
  },
  'rent': {
    id: 'rent',
    name: 'Rent Management',
    routes: ['/rent', '/rent/*'],
    version: '1.0.0',
    permissions: ['rent:view'],
    enabled: true,
  },
  'return': {
    id: 'return',
    name: 'Return Management',
    routes: ['/return', '/return/*'],
    version: '1.0.0',
    permissions: ['return:view'],
    enabled: true,
  },
  'vehicle-exchange': {
    id: 'vehicle-exchange',
    name: 'Vehicle Exchange',
    routes: ['/vehicle_exchange', '/vehicle_exchange/*'],
    version: '1.0.0',
    permissions: ['exchange:view'],
    enabled: true,
  },
  'reservation-lookup': {
    id: 'reservation-lookup',
    name: 'Reservation Lookup',
    routes: ['/reservation_lookup', '/reservation_lookup/*'],
    version: '1.0.0',
    enabled: true,
  },
  'car-control': {
    id: 'car-control',
    name: 'Car Control',
    routes: ['/carcontrol', '/carcontrol/*'],
    version: '1.0.0',
    permissions: ['fleet:view'],
    enabled: true,
  },
  'aao': {
    id: 'aao',
    name: 'AAO',
    routes: ['/aao', '/aao/*'],
    version: '1.0.0',
    permissions: ['aao:view'],
    enabled: true,
  },
  'reports': {
    id: 'reports',
    name: 'Reports',
    routes: ['/reports', '/reports/*'],
    version: '1.0.0',
    permissions: ['reports:view'],
    enabled: true,
  },
  'settings': {
    id: 'settings',
    name: 'Settings',
    routes: ['/settings', '/settings/*'],
    version: '1.0.0',
    permissions: ['settings:view'],
    enabled: true,
  },
};

/**
 * MFE loading state store - tracks loading state for each MFE
 */
interface MfeLoadingStore {
  states: Record<string, MfeLoadingState>;
  setLoading: (mfeId: string, state: MfeLoadingState) => void;
  getState: (mfeId: string) => MfeLoadingState;
}

export const useMfeLoadingStore = create<MfeLoadingStore>((set, get) => ({
  states: {},
  setLoading: (mfeId, state) => {
    set((prev) => ({
      states: { ...prev.states, [mfeId]: state },
    }));
  },
  getState: (mfeId) => get().states[mfeId] || 'idle',
}));

/**
 * Get MFE metadata by route path
 */
export function getMfeByRoute(pathname: string): MfeMetadata | undefined {
  return Object.values(mfeRegistry).find((mfe) =>
    mfe.routes.some((route) => {
      if (route.endsWith('/*')) {
        const prefix = route.slice(0, -2);
        return pathname.startsWith(prefix);
      }
      return pathname === route;
    })
  );
}

/**
 * Check if MFE is enabled
 */
export function isMfeEnabled(mfeId: string): boolean {
  return mfeRegistry[mfeId]?.enabled ?? false;
}
```
  </action>
  <verify>
- `apps/shell/src/services/mfe-registry.ts` exists
- Exports mfeRegistry with all 9 MFEs
- getMfeByRoute function works correctly
  </verify>
  <done>MFE registry service created with metadata for all 9 MFEs</done>
</task>

<task type="auto">
  <name>Task 2: Create MFE error boundary component</name>
  <files>
    - apps/shell/src/components/MfeErrorBoundary.tsx
  </files>
  <action>
1. Create `apps/shell/src/components/MfeErrorBoundary.tsx`:
```typescript
import React from 'react';
import { Card, CardContent, Button } from '@packages/ui';
import { AlertTriangle, RefreshCw } from 'lucide-react';

interface MfeErrorBoundaryProps {
  children: React.ReactNode;
  mfeName?: string;
  fallback?: React.ReactNode;
  onRetry?: () => void;
}

interface MfeErrorBoundaryState {
  hasError: boolean;
  error?: Error;
}

/**
 * Error boundary that isolates MFE failures
 * One MFE crashing won't bring down the shell or other MFEs
 */
export class MfeErrorBoundary extends React.Component<
  MfeErrorBoundaryProps,
  MfeErrorBoundaryState
> {
  constructor(props: MfeErrorBoundaryProps) {
    super(props);
    this.state = { hasError: false };
  }

  static getDerivedStateFromError(error: Error): MfeErrorBoundaryState {
    return { hasError: true, error };
  }

  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {
    // Log to console for debugging
    console.error(
      `[MFE Error] ${this.props.mfeName || 'Unknown MFE'}:`,
      error,
      errorInfo
    );

    // Could emit event to monitoring service in production
    // eventBus.emit('mfe:error', { mfeName: this.props.mfeName, error });
  }

  handleRetry = () => {
    this.setState({ hasError: false, error: undefined });
    this.props.onRetry?.();
  };

  render() {
    if (this.state.hasError) {
      // Custom fallback if provided
      if (this.props.fallback) {
        return this.props.fallback;
      }

      // Default minimal inline error UI (per CONTEXT.md: "minimal inline error where MFE would render")
      return (
        <Card className="border-red-200 bg-red-50">
          <CardContent className="p-6">
            <div className="flex items-start gap-4">
              <div className="flex-shrink-0">
                <AlertTriangle className="h-6 w-6 text-red-500" />
              </div>
              <div className="flex-1">
                <h3 className="font-semibold text-red-800">
                  {this.props.mfeName || 'This section'} failed to load
                </h3>
                <p className="text-sm text-red-600 mt-1">
                  {this.state.error?.message || 'An unexpected error occurred'}
                </p>
                <Button
                  variant="outline"
                  size="sm"
                  className="mt-4"
                  onClick={this.handleRetry}
                >
                  <RefreshCw className="h-4 w-4 mr-2" />
                  Try again
                </Button>
              </div>
            </div>
          </CardContent>
        </Card>
      );
    }

    return this.props.children;
  }
}

// Functional wrapper for easier use with hooks
export function withMfeErrorBoundary<P extends object>(
  WrappedComponent: React.ComponentType<P>,
  mfeName: string
) {
  return function MfeErrorBoundaryWrapper(props: P) {
    return (
      <MfeErrorBoundary mfeName={mfeName}>
        <WrappedComponent {...props} />
      </MfeErrorBoundary>
    );
  };
}
```
  </action>
  <verify>
- `apps/shell/src/components/MfeErrorBoundary.tsx` exists
- Component has getDerivedStateFromError and componentDidCatch
- Renders minimal inline error UI when MFE crashes
- Has retry functionality
  </verify>
  <done>MFE error boundary component created for failure isolation</done>
</task>

<task type="auto">
  <name>Task 3: Create loading progress bar for lazy route loading</name>
  <files>
    - apps/shell/src/components/MfeLoadingBar.tsx
    - apps/shell/src/routes/__root.tsx
  </files>
  <action>
1. Create `apps/shell/src/components/MfeLoadingBar.tsx`:
```typescript
import { useRouterState } from '@tanstack/react-router';
import { useEffect, useState } from 'react';
import { cn } from '@packages/ui';

/**
 * Thin progress bar at top of page during route loading
 * Styled like GitHub/YouTube page transitions (per CONTEXT.md)
 */
export function MfeLoadingBar() {
  const isLoading = useRouterState({ select: (s) => s.status === 'pending' });
  const [progress, setProgress] = useState(0);
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (isLoading) {
      setVisible(true);
      setProgress(0);

      // Simulate progress (actual loading is async, we animate for UX)
      const timer1 = setTimeout(() => setProgress(30), 100);
      const timer2 = setTimeout(() => setProgress(60), 300);
      const timer3 = setTimeout(() => setProgress(80), 600);

      return () => {
        clearTimeout(timer1);
        clearTimeout(timer2);
        clearTimeout(timer3);
      };
    } else {
      // Complete the progress bar
      setProgress(100);

      // Hide after animation completes
      const hideTimer = setTimeout(() => {
        setVisible(false);
        setProgress(0);
      }, 200);

      return () => clearTimeout(hideTimer);
    }
  }, [isLoading]);

  if (!visible && !isLoading) return null;

  return (
    <div className="fixed top-0 left-0 right-0 z-[100] h-1 bg-transparent">
      <div
        className={cn(
          'h-full bg-yellow-500 transition-all duration-200 ease-out',
          progress === 100 && 'opacity-0'
        )}
        style={{ width: `${progress}%` }}
      />
    </div>
  );
}
```
2. Update `apps/shell/src/routes/__root.tsx` to include the loading bar:
```typescript
import { MfeLoadingBar } from '../components/MfeLoadingBar';

// In the root component render:
return (
  <>
    <MfeLoadingBar />
    <Outlet />
  </>
);
```
  </action>
  <verify>
- `apps/shell/src/components/MfeLoadingBar.tsx` exists
- Loading bar shows during route transitions
- Bar animates from left to right
- Bar disappears after route loads
  </verify>
  <done>Loading progress bar created for lazy route loading feedback</done>
</task>

</tasks>

<verification>
- `pnpm --filter @apps/shell dev` runs
- Navigate between routes - see loading bar animate
- Artificially trigger error in a route - see error boundary UI
- Other routes still work when one has error
</verification>

<success_criteria>
- MFE registry exports metadata for all 9 MFEs
- Error boundary isolates MFE crashes (shell continues working)
- Loading bar shows during lazy route transitions
- getMfeByRoute correctly identifies MFE from path
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-07-SUMMARY.md`
</output>
