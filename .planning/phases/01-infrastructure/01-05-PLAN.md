---
phase: 01-infrastructure
plan: 05
type: execute
wave: 2
depends_on: ["01-04"]
files_modified:
  - apps/shell/src/services/auth.ts
  - apps/shell/src/store/useAuthStore.ts
  - apps/shell/src/routes/_auth.tsx
autonomous: true

must_haves:
  truths:
    - "Auth store provides login state, session management, and role checks"
    - "Protected routes redirect to login when not authenticated"
    - "Unauthorized nav items are hidden based on role"
  artifacts:
    - path: "apps/shell/src/services/auth.ts"
      provides: "AuthService implementation"
      contains: "hasRole"
    - path: "apps/shell/src/store/useAuthStore.ts"
      provides: "Zustand auth store with persist"
      contains: "persist"
  key_links:
    - from: "apps/shell/src/services/auth.ts"
      to: "@packages/mfe-types"
      via: "imports AuthService interface"
      pattern: "import.*AuthService.*@packages/mfe-types"
---

<objective>
Implement auth service with login state, session management, and role-based access

Purpose: Provide shell-level auth service that MFEs can consume without coupling. This enables consistent auth behavior across all MFEs.
Output: Working auth service with role checks, session persistence, and redirect to login for unauthenticated access
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/01-infrastructure/01-RESEARCH.md
@.planning/phases/01-infrastructure/01-CONTEXT.md
@.planning/phases/01-infrastructure/01-04-SUMMARY.md

# Existing auth store for reference
@apps/shell/src/store/useAuthStore.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Enhance auth store with typed Role and session management</name>
  <files>
    - apps/shell/src/store/useAuthStore.ts
    - apps/shell/src/config/roles.ts
    - apps/shell/src/config/users.ts
  </files>
  <action>
1. Update `apps/shell/src/config/roles.ts` to use types from @packages/mfe-types:
```typescript
import type { Role } from '@packages/mfe-types';

export type { Role };

// Role hierarchy for permission checks
export const ROLE_HIERARCHY: Record<Role, number> = {
  admin: 4,
  manager: 3,
  agent: 2,
  viewer: 1,
};
```
2. Update `apps/shell/src/config/users.ts` to use typed Role:
```typescript
import type { Role } from '@packages/mfe-types';

export interface DummyUser {
  username: string;
  password: string;
  role: Role;
}

export const DUMMY_USERS: DummyUser[] = [
  { username: 'admin', password: 'admin', role: 'admin' },
  { username: 'manager', password: 'manager', role: 'manager' },
  { username: 'agent', password: 'agent', role: 'agent' },
  { username: 'viewer', password: 'viewer', role: 'viewer' },
];
```
3. Update `apps/shell/src/store/useAuthStore.ts`:
```typescript
import { create } from 'zustand';
import { persist } from 'zustand/middleware';
import type { Role, User, AuthState } from '@packages/mfe-types';
import { DUMMY_USERS } from '../config/users';
import { ROLE_HIERARCHY } from '../config/roles';

interface AuthStore extends AuthState {
  // Actions
  login: (username: string, password: string) => boolean;
  logout: () => void;
  // Role checks
  hasRole: (role: Role) => boolean;
  hasAnyRole: (roles: Role[]) => boolean;
  // For router context
  userId: string;
  role: Role | null;
  isLoggedIn: boolean;
}

const useAuthStore = create<AuthStore>()(
  persist(
    (set, get) => ({
      // State
      user: null,
      isAuthenticated: false,
      isLoading: false,
      userId: '',
      role: null,
      isLoggedIn: false,

      // Actions
      login: (username, password) => {
        const dummyUser = DUMMY_USERS.find(
          (u) => u.username === username && u.password === password
        );

        if (!dummyUser) return false;

        const user: User = {
          id: dummyUser.username,
          username: dummyUser.username,
          role: dummyUser.role,
        };

        set({
          user,
          isAuthenticated: true,
          isLoggedIn: true,
          userId: user.username,
          role: user.role,
        });

        return true;
      },

      logout: () => {
        set({
          user: null,
          isAuthenticated: false,
          isLoggedIn: false,
          userId: '',
          role: null,
        });
      },

      // Role checks
      hasRole: (role) => {
        const currentRole = get().role;
        if (!currentRole) return false;
        return ROLE_HIERARCHY[currentRole] >= ROLE_HIERARCHY[role];
      },

      hasAnyRole: (roles) => {
        const currentRole = get().role;
        if (!currentRole) return false;
        return roles.some((role) => ROLE_HIERARCHY[currentRole] >= ROLE_HIERARCHY[role]);
      },
    }),
    {
      name: 'auth-storage',
      partialize: (state) => ({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
        isLoggedIn: state.isLoggedIn,
        userId: state.userId,
        role: state.role,
      }),
    }
  )
);

export default useAuthStore;
```
  </action>
  <verify>
- TypeScript compiles without errors
- Auth store imports from @packages/mfe-types
- hasRole and hasAnyRole methods exist
  </verify>
  <done>Auth store enhanced with typed Role from @packages/mfe-types and role hierarchy checks</done>
</task>

<task type="auto">
  <name>Task 2: Create AuthService that implements the interface for MFEs</name>
  <files>
    - apps/shell/src/services/auth.ts
  </files>
  <action>
1. Create `apps/shell/src/services/` directory if it doesn't exist
2. Create `apps/shell/src/services/auth.ts`:
```typescript
import type { AuthService, AuthState, Role } from '@packages/mfe-types';
import useAuthStore from '../store/useAuthStore';

/**
 * Auth service implementation for MFEs to consume
 * Wraps Zustand store to implement AuthService interface
 */
export const authService: AuthService = {
  getState: (): AuthState => {
    const state = useAuthStore.getState();
    return {
      user: state.user,
      isAuthenticated: state.isAuthenticated,
      isLoading: state.isLoading,
    };
  },

  hasRole: (role: Role): boolean => {
    return useAuthStore.getState().hasRole(role);
  },

  hasAnyRole: (roles: Role[]): boolean => {
    return useAuthStore.getState().hasAnyRole(roles);
  },

  subscribe: (callback: (state: AuthState) => void): (() => void) => {
    return useAuthStore.subscribe((state) => {
      callback({
        user: state.user,
        isAuthenticated: state.isAuthenticated,
        isLoading: state.isLoading,
      });
    });
  },
};

// Re-export the store hook for components that need it
export { useAuthStore };
```
  </action>
  <verify>
- `apps/shell/src/services/auth.ts` exports authService implementing AuthService interface
- TypeScript compiles without errors (interface is satisfied)
  </verify>
  <done>AuthService implementation created for MFEs to consume</done>
</task>

<task type="auto">
  <name>Task 3: Update sidebar to hide nav items based on role</name>
  <files>
    - apps/shell/src/components/Sidebar.tsx
    - apps/shell/src/config/sidebar-menu.config.ts
  </files>
  <action>
1. Update `apps/shell/src/config/sidebar-menu.config.ts` to ensure roles array is properly typed:
```typescript
import type { Role } from '@packages/mfe-types';

export interface MenuItemChild {
  label: string;
  icon?: string;
  pathname?: string;
}

export interface MenuItemType {
  label: string;
  icon: string;
  children?: MenuItemChild[];
  roles: Role[];
}
```
2. Update `apps/shell/src/components/Sidebar.tsx`:
   - Import `hasAnyRole` check from auth store
   - Filter menu items: `const visibleItems = menuItems.filter((item) => hasAnyRole(item.roles))`
   - The existing code already does role filtering, ensure it uses the new typed roles
3. Verify that:
   - Admin sees all menu items
   - Agent sees only agent-level items
   - Viewer sees only viewer-level items
  </action>
  <verify>
- Sidebar filters menu items based on user role
- Login as different users shows different menu items
- No TypeScript errors in Sidebar component
  </verify>
  <done>Sidebar hides unauthorized nav items based on user role</done>
</task>

</tasks>

<verification>
- `pnpm --filter @apps/shell dev` runs without errors
- Login as admin shows all menu items
- Login as agent shows fewer menu items
- Logout and try to access /dashboard redirects to /login
</verification>

<success_criteria>
- Auth store uses Role type from @packages/mfe-types
- AuthService interface implemented and exported
- Role-based nav item filtering works
- Session persists across page refreshes
</success_criteria>

<output>
After completion, create `.planning/phases/01-infrastructure/01-05-SUMMARY.md`
</output>
